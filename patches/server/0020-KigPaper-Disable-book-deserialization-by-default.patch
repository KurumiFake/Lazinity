From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: RoccoDev <hey@rocco.dev>
Date: Mon, 26 Apr 2021 09:25:19 +0200
Subject: [PATCH] (KigPaper) Disable book deserialization by default

Original code by ProjectKig, licensed under GPLv3
You can find the original code on https://github.com/ProjectKig/KigPaper

diff --git a/src/main/java/me/kurumifake/lazinity/LazinityConfig.java b/src/main/java/me/kurumifake/lazinity/LazinityConfig.java
new file mode 100644
index 0000000000000000000000000000000000000000..ba5f6e80cbfd8326b1786f1fc1a0f6cac4771454
--- /dev/null
+++ b/src/main/java/me/kurumifake/lazinity/LazinityConfig.java
@@ -0,0 +1,126 @@
+package me.kurumifake.lazinity;
+
+import org.bukkit.Bukkit;
+import org.bukkit.configuration.file.YamlConfiguration;
+
+import java.io.File;
+import java.lang.reflect.Method;
+import java.lang.reflect.Modifier;
+import java.util.logging.Level;
+
+public final class LazinityConfig {
+
+    public static final String CONFIG_HEADER = "Configuration file for Lazinity.";
+    public static final int CURRENT_CONFIG_VERSION = 0;
+
+    private static final Object[] EMPTY = new Object[0];
+
+    private static File configFile;
+    private static YamlConfiguration config;
+    private static int configVersion;
+
+    public static void init(final File file) {
+        LazinityConfig.configFile = file;
+        LazinityConfig.config = new YamlConfiguration();
+        config.options().header(CONFIG_HEADER);
+        config.options().copyDefaults(true);
+
+        if (!file.exists()) {
+            try {
+                file.createNewFile();
+            } catch (final Exception ex) {
+                System.out.println("Failure to create Lazinity config");
+                ex.printStackTrace();
+            }
+        } else {
+            try {
+                config.load(file);
+            } catch (final Exception ex) {
+                System.out.println("Failure to load Lazinity config");
+                throw new RuntimeException(ex);
+            }
+        }
+
+        LazinityConfig.load(LazinityConfig.class, null);
+    }
+
+    public static void load(Class<?> clazz, Object instance) {
+        LazinityConfig.configVersion = LazinityConfig.getInt("config-version-please-do-not-modify-me", CURRENT_CONFIG_VERSION);
+
+        for (final Method method : clazz.getDeclaredMethods()) {
+            if (method.getReturnType() != void.class || method.getParameterCount() != 0 ||
+                    !Modifier.isPrivate(method.getModifiers()) || (instance == null && !Modifier.isStatic(method.getModifiers()))) {
+                continue;
+            }
+
+            try {
+                method.setAccessible(true);
+                method.invoke(instance, EMPTY);
+            } catch (final Exception ex) {
+                throw new RuntimeException(ex);
+            }
+        }
+
+        /* We re-save to add new options */
+        try {
+            config.save(LazinityConfig.configFile);
+        } catch (final Exception ex) {
+            System.out.println("Unable to save Lazinity config");
+            ex.printStackTrace();
+        }
+    }
+
+    private static boolean getBoolean(final String path, final boolean dfl) {
+        LazinityConfig.config.addDefault(path, Boolean.valueOf(dfl));
+        return LazinityConfig.config.getBoolean(path, dfl);
+    }
+
+    private static int getInt(final String path, final int dfl) {
+        LazinityConfig.config.addDefault(path, Integer.valueOf(dfl));
+        return LazinityConfig.config.getInt(path, dfl);
+    }
+
+    private static double getDouble(final String path, final double dfl) {
+        LazinityConfig.config.addDefault(path, Double.valueOf(dfl));
+        return LazinityConfig.config.getDouble(path, dfl);
+    }
+
+    private static long getLong(final String path, final long dfl) {
+        LazinityConfig.config.addDefault(path, Long.valueOf(dfl));
+        return LazinityConfig.config.getLong(path, dfl);
+    }
+
+    public static final class WorldConfig {
+
+        public final String worldName;
+
+        public WorldConfig(final String worldName) {
+            this.worldName = worldName;
+            this.init();
+        }
+
+        public void init() {
+            load(WorldConfig.class, this);
+        }
+
+        private boolean getBoolean(final String path, final boolean dfl) {
+            config.addDefault("worlds.default." + path, Boolean.valueOf(dfl));
+            return config.getBoolean("worlds." + worldName + "." + path, config.getBoolean("worlds.default." + path, dfl));
+        }
+
+        private int getInt(final String path, final int dfl) {
+            config.addDefault("worlds.default." + path, Integer.valueOf(dfl));
+            return config.getInt("worlds." + worldName + "." + path, config.getInt("worlds.default." + path, dfl));
+        }
+
+        private double getDouble(final String path, final double dfl) {
+            config.addDefault("worlds.default." + path, Double.valueOf(dfl));
+            return config.getDouble("worlds." + worldName + "." + path, config.getDouble("worlds.default." + path, dfl));
+        }
+    }
+
+    public static boolean enableBookDeserialization;
+    private static void enableBookDeserialization() {
+        enableBookDeserialization = getBoolean("enable-book-deserialization", false);
+    }
+}
diff --git a/src/main/java/net/minecraft/server/network/PlayerConnection.java b/src/main/java/net/minecraft/server/network/PlayerConnection.java
index 2cc893cd9da8339d3c4a79ff206143fce41a4de0..d071f3d277ff25b8bc5760091b25fd5fdd11fdc9 100644
--- a/src/main/java/net/minecraft/server/network/PlayerConnection.java
+++ b/src/main/java/net/minecraft/server/network/PlayerConnection.java
@@ -1153,6 +1153,7 @@ public class PlayerConnection implements PacketListenerPlayIn {
         }
         // Paper end
         // CraftBukkit start
+        if (!me.kurumifake.lazinity.LazinityConfig.enableBookDeserialization) return; // KigPaper
         if (this.lastBookTick + 20 > MinecraftServer.currentTick) {
             this.disconnect("Book edited too quickly!", org.bukkit.event.player.PlayerKickEvent.Cause.ILLEGAL_ACTION); // Paper - kick event cause
             return;
